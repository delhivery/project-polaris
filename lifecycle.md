# Lifecycle

## Overview

The lifecycle of any object can be thought of as a state machine such that each entity or each of its sub-entities is exactly always in one of a possible number of states and where there are well-defined conditional transitions between these states.

Business/Product can declare the lifecycle of each model in the system and events associated with each state of the lifecycle. The events may cause change in state of a model's lifecycle

## Technical Definition

A lifecycle is a sequence of events associated with a model that governs the actions available (or to be performed) on instances of the model. Additionally, lifecycles can be chained to create larger lifecycles.

```ts
enum Comparator = {
	"eq", "ne", "lte", "gte", "gt", "lt"
}

interface ChoiceDef {
	expression: JsonPath;
	compare: Comparator;
	value: string | boolean | number | null;
	emit: EventDrn[];
}

interface EventDef {
	task: CallbackDrn;
	choice: ChoiceDef[];
	next: EventDrn[];
	emit: EventDrn[];
}

interface Lifecycle {
	drn: LifecycleDrn;
	modelDrn: ModelDrn;
	start: EventDrn;
	events: EventDef;
}

interface ModelInstance {
	__lc_state: EventDrn;
	__lc_ver: number;
	__lc: LifeCycle;
	[key:string]: any;
}
```

### Compilation

When lifecycle is registered, it is stored in a compiled format. The child lifecycle definition is replaced with the lifecycle drn and all the child event defs are added to the root.

```ts
const compile = (lifecycle) => {
	let childEventDefs: { [key: string]: EventDef } = {};
	for (const event of Object.keys(lifecycle.def.events)) {
		const eventDef = lifecycle.def.events[event];
		if (eventDef.choice) {
			for (const choiceDef of eventDef.choice) {
				const childLifeCycle = await this.load(choiceDef.emit); // Get compiled version of child lc
				childEventDefs = {
					...childEventDefs,
					...childLifeCycle.events,
				};
				choiceDef.emit = childLifeCycle.start;
			}
		}
	}
	lifecycle.def.events = {
		...lifecycle.def.events,
		...childEventDefs,
	};
	return lifecycle;
};
```

### Execution

Lifecycle is executed when an event is generated. An event can be generated by integration endpoints (HTTP Api, Message Queues, RPC). Lifecycles are themselves executed as an event loop which is governed by the definition above.

When an event is generated, the history of all events are retrieved for the instance and the new event is appended to it. Then the entire event history is verified against the model lifecycle. If, the event succeeds, the history of the instance is updated, else the event is rejected.

To reduce the complexity of re-running the historical events, history of an object can be serialized/deserialized as a state store.

```ts
const isValidNextEvent = (event, modelInstance): boolean => {
	if (modelInstance.__lc_state === undefined) {
		return event === modelInstance.__lc.start;
	} else {
		return (
			modelInstance.__lc.events[modelInstance.__lc_state] !== undefined &&
			(modelInstance.__lc.events[modelInstance.__lc_state].next.includes(
				event
			) ||
				lifecyclemodelInstance.__lc.events[
					modelInstance.__lc_state
				].choice
					.map((v) => {
						return v.emit;
					})
					.includes(event))
		);
	}
};

const evaluateChoices = async (choices, modelInstance): Promise<string> => {
	const evaluate = (modelInstance: any, choice: ChoiceDef): boolean => {
		if (choice.expression === undefined) return true;

		if (modelInstance !== undefined) {
			switch (choice.compare) {
				case "eq":
				case undefined:
					return (
						choice.value ===
						query(modelInstance, choice.expression)[0]
					);

				case "gt":
					return (
						choice.value !== null &&
						query(modelInstance, choice.expression)[0] >
							choice.value
					);

				case "gte":
					return (
						choice.value !== null &&
						query(modelInstance, choice.expression)[0] >=
							choice.value
					);

				case "lt":
					return (
						choice.value !== null &&
						query(modelInstance, choice.expression)[0] <
							choice.value
					);

				case "lte":
					return (
						choice.value !== null &&
						query(modelInstance, choice.expression)[0] <=
							choice.value
					);

				case "ne":
					return (
						choice.value !==
						query(modelInstance, choice.expression)[0]
					);

				default:
					return false;
			}
		}
		return false;
	};

	for (const choice of choices) {
		try {
			if (evaluate(modelInstance, choice)) {
				return await this.next(choice.emit, modelInstance);
			}
		} catch (e) {
			//
		}
	}
	throw new InvalidOperationError();
};

const next = async (event, modelInstance) => {
	if (!isValidNextEvent(event, modelInstance)) {
		throw new InvalidEventError(event);
	}
	const eventDef = modelInstance.__lc.events[event];
	if (eventDef.task) {
		return eventDef.task;
	} else if (eventDef.choice && eventDef.choice.length > 0) {
		return await this.evaluateChoices(eventDef.choice, modelInstance);
	} else {
		throw new InvalidOperationError();
	}
};
```
