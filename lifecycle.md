# Lifecycle

## Overview

The lifecycle of any object can be thought of as a state machine such that each entity or each of its sub-entities is exactly always in one of a possible number of states and where there are well-defined conditional transitions between these states.

Business/Product can declare the lifecycle of each model in the system and events associated with each state of the lifecycle. The events may cause change in state of a model's lifecycle

## Technical Definition

A lifecycle is a sequence of events associated with a model that governs the actions available (or to be performed) on instances of the model. Additionally, lifecycles can be chained to create larger lifecycles.



```ts
// DSL for lifecycle
{
  "name": "string",
  "start": "<event_drn>",
  "guard": {
    "name": "string",
    "expression": "JSONPath"
  },
  "<event_drn>": {
    "callback": "<callback_drn>",
    "next": [
      "<event_drn>",
      "<lifecycle_drn>",
    ],
    "emit": [
      "<event_drn>",
    ]
  },
}

// Constraints on events
for(const eventDefinition: lifecycle.events) {
  nextEvents = [event_drn for event in eventDefinition.next] + [lifecycle.start for lifecycle in eventDefinition.next];

  if (nextEvents.length() != set(nextEvents).length) {
    throw Error("Invalid event definition. Multiple executions for event found in chain");
  }
}
```

### Execution

Lifecycle is executed when an event is generated. An event can be generated by integration endpoints (HTTP Api, Message Queues, RPC). Lifecycles are themselves executed as an event loop which is governed by the definition above.

When an event is generated, the history of all events are retrieved for the instance and the new event is appended to it. Then the entire event history is verified against the model lifecycle. If, the event succeeds, the history of the instance is updated, else the event is rejected.

To reduce the complexity of re-running the historical events, history of an object can be serialized/deserialized as a state store.

```ts
const can_process_lifecycle = (lifecycle, events) => {
  next_event = lifecycle.start;

  if (events.length == 0) return true;

  if (events[0] != next_event) return false;

  return process_lifecycle(lifecycle[events[0]], events[1:]);
};

loopback.on("event", (instance, event) => {
  history = instance.event_history();
  history.append(event);

  lifecycle = instance.model.lifecycle()

  if (!can_process_lifecycle(lifecycle, history)) 
    throw UnexpectedEvent("Event is not supported at its current state in lifecycle");

  eventDefinition = lifecycle[event];

  if (error = eventDefinition["callback"]()) {
    instance.event_history(history);
    return;
  }

  throw EventExecutionFailure("Error executing event: ", error);
});
```


### Capability

Since lifecycles can contain other lifecycles, we can guard optional sub-lifecycles by abstracting them behind guard conditions.

```ts
loopback.on(..., {

  ...
  eventDefinition = lifecycle[event];

  if (eventDefinition.type == 'lifecycle' and eventDefinition.guard and eval(eventDefinition.guard.expression)) {
    // invoke sub-lifecycle
  }
  throw GuardConditionFailed("Error executing event: Object lacks capability ", eventDefinition.guard.name)
});
```